<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">&quot;use strict&quot;;
Object.defineProperty(exports, &quot;__esModule&quot;, { value: true });
exports.assertNever = exports.removeWithPredicate = exports.remove = exports.ellipsis = exports.defaults = exports.isBoolean = exports.isUndefined = void 0;
<span id='global-method-isUndefined'>/**
</span> * Simpler helper method to check for undefined simply for the benefit of
 * gaining better compression when minified by not needing to have multiple
 * comparisons to the `undefined` keyword in the codebase.
 */
function isUndefined(value) {
    return value === undefined;
}
exports.isUndefined = isUndefined;
<span id='global-method-isBoolean'>/**
</span> * Simpler helper method to check for a boolean type simply for the benefit of
 * gaining better compression when minified by not needing to have multiple
 * `typeof` comparisons in the codebase.
 */
function isBoolean(value) {
    return typeof value === &#39;boolean&#39;;
}
exports.isBoolean = isBoolean;
<span id='global-method-defaults'>/**
</span> * Assigns (shallow copies) the properties of `src` onto `dest`, if the
 * corresponding property on `dest` === `undefined`.
 *
 * @param {Object} dest The destination object.
 * @param {Object} src The source object.
 * @return {Object} The destination object (`dest`)
 */
function defaults(dest, src) {
    for (var prop in src) {
        if (src.hasOwnProperty(prop) &amp;&amp; isUndefined(dest[prop])) {
            dest[prop] = src[prop];
        }
    }
    return dest;
}
exports.defaults = defaults;
<span id='global-method-ellipsis'>/**
</span> * Truncates the `str` at `len - ellipsisChars.length`, and adds the `ellipsisChars` to the
 * end of the string (by default, two periods: &#39;..&#39;). If the `str` length does not exceed
 * `len`, the string will be returned unchanged.
 *
 * @param {String} str The string to truncate and add an ellipsis to.
 * @param {Number} truncateLen The length to truncate the string at.
 * @param {String} [ellipsisChars=...] The ellipsis character(s) to add to the end of `str`
 *   when truncated. Defaults to &#39;...&#39;
 */
function ellipsis(str, truncateLen, ellipsisChars) {
    var ellipsisLength;
    if (str.length &gt; truncateLen) {
        if (ellipsisChars == null) {
            ellipsisChars = &#39;&amp;hellip;&#39;;
            ellipsisLength = 3;
        }
        else {
            ellipsisLength = ellipsisChars.length;
        }
        str = str.substring(0, truncateLen - ellipsisLength) + ellipsisChars;
    }
    return str;
}
exports.ellipsis = ellipsis;
<span id='global-method-remove'>/**
</span> * Removes array elements by value. Mutates the input array.
 *
 * Using this instead of the ES5 Array.prototype.filter() function to prevent
 * creating many new arrays in memory for removing an element.
 *
 * @param arr The array to remove elements from. This array is mutated.
 * @param fn The element to remove.
 */
function remove(arr, item) {
    for (var i = arr.length - 1; i &gt;= 0; i--) {
        if (arr[i] === item) {
            arr.splice(i, 1);
        }
    }
}
exports.remove = remove;
<span id='global-method-removeWithPredicate'>/**
</span> * Removes array elements based on a filtering function. Mutates the input
 * array.
 *
 * Using this instead of the ES5 Array.prototype.filter() function to prevent
 * creating many new arrays in memory for filtering.
 *
 * @param arr The array to remove elements from. This array is mutated.
 * @param fn The predicate function which should return `true` to remove an
 *   element.
 */
function removeWithPredicate(arr, fn) {
    for (var i = arr.length - 1; i &gt;= 0; i--) {
        if (fn(arr[i]) === true) {
            arr.splice(i, 1);
        }
    }
}
exports.removeWithPredicate = removeWithPredicate;
<span id='global-method-assertNever'>/**
</span> * Function that should never be called but is used to check that every
 * enum value is handled using TypeScript&#39;s &#39;never&#39; type.
 */
function assertNever(theValue) {
    throw new Error(&quot;Unhandled case for value: &#39;&quot;.concat(theValue, &quot;&#39;&quot;));
}
exports.assertNever = assertNever;
//# sourceMappingURL=utils.js.map</pre>
</body>
</html>
